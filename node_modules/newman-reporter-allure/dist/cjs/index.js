"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _allureJsCommons = require("allure-js-commons");
var _reporter = require("allure-js-commons/sdk/reporter");
var _utils = require("./utils.js");
var _excluded = ["resultsDir"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); } /* eslint-disable @typescript-eslint/unbound-method */
var _AllureReporter_brand = /*#__PURE__*/new WeakSet();
class AllureReporter {
  constructor(emitter, reporterConfig, options) {
    _classPrivateMethodInitSpec(this, _AllureReporter_brand);
    _defineProperty(this, "allureRuntime", void 0);
    _defineProperty(this, "allureConfig", void 0);
    _defineProperty(this, "runningItems", []);
    _defineProperty(this, "currentCollection", void 0);
    _defineProperty(this, "pmItemsByAllureUuid", new Map());
    _defineProperty(this, "currentTest", void 0);
    _defineProperty(this, "currentScope", void 0);
    _defineProperty(this, "rootCollectionName", void 0);
    var {
        resultsDir
      } = reporterConfig,
      restConfig = _objectWithoutProperties(reporterConfig, _excluded);
    this.currentCollection = options.collection;
    this.rootCollectionName = options.collection.name;
    this.allureConfig = reporterConfig;
    this.allureRuntime = new _reporter.ReporterRuntime(_objectSpread(_objectSpread({}, restConfig), {}, {
      writer: (0, _reporter.createDefaultWriter)({
        resultsDir,
        emitter
      })
    }));
    this.registerEvents(emitter);
  }
  registerEvents(emitter) {
    emitter.on("start", this.onStart.bind(this));
    emitter.on("beforeItem", this.onBeforeItem.bind(this));
    emitter.on("item", this.onItem.bind(this));
    emitter.on("prerequest", this.onPrerequest.bind(this));
    emitter.on("request", this.onRequest.bind(this));
    emitter.on("test", this.onTest.bind(this));
    emitter.on("assertion", this.onAssertion.bind(this));
    emitter.on("console", this.onConsole.bind(this));
    emitter.on("done", this.onDone.bind(this));
  }
  onStart() {
    this.currentScope = this.allureRuntime.startScope();
  }
  onPrerequest(err, args) {
    var _args$executions$;
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem) {
      return;
    }
    currentPmItem.prerequest = (_args$executions$ = args.executions[0]) === null || _args$executions$ === void 0 || (_args$executions$ = _args$executions$.script) === null || _args$executions$ === void 0 || (_args$executions$ = _args$executions$.exec) === null || _args$executions$ === void 0 ? void 0 : _args$executions$.join("\n");
  }
  onBeforeItem(err, args) {
    var pmItem = {
      name: args.item.name,
      passed: true,
      failedAssertions: [],
      consoleLogs: []
    };
    var itemGroup = args.item.parent();
    var item = args.item;
    var fullName = _assertClassBrand(_AllureReporter_brand, this, _getFullName).call(this, item);
    var testPath = _assertClassBrand(_AllureReporter_brand, this, _pathToItem).call(this, item);
    var hostLabel = (0, _reporter.getHostLabel)();
    var threadLabel = (0, _reporter.getThreadLabel)();
    var {
      labels
    } = (0, _utils.extractMeta)(args.item.events);
    this.currentTest = this.allureRuntime.startTest({
      name: args.item.name,
      fullName,
      stage: _allureJsCommons.Stage.RUNNING,
      labels: [(0, _reporter.getLanguageLabel)(), (0, _reporter.getFrameworkLabel)("newman"), hostLabel, threadLabel, ...labels, ...(0, _reporter.getEnvironmentLabels)()]
    });
    this.allureRuntime.updateTest(this.currentTest, test => {
      test.labels.push(...(0, _reporter.getSuiteLabels)(testPath));
    });
    this.pmItemsByAllureUuid.set(this.currentTest, pmItem);
    if (itemGroup && this.currentCollection !== itemGroup) {
      this.currentCollection = itemGroup;
    }
  }
  onItem(err, args) {
    var _requestData$headers, _requestData$body, _response$headers;
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem) {
      return;
    }
    var requestData = currentPmItem.requestData;
    var requestDataURL = requestData && "".concat(requestData.method, " - ").concat(requestData.url);
    var rawDescription = args.item.request.description;
    var testDescription = (typeof rawDescription === "string" ? rawDescription : rawDescription === null || rawDescription === void 0 ? void 0 : rawDescription.content) || "";
    var response = currentPmItem.responseData;
    var failedAssertions = currentPmItem.failedAssertions;
    var requestError = currentPmItem.requestError;
    if (currentPmItem.prerequest) {
      _assertClassBrand(_AllureReporter_brand, this, _attachString).call(this, "PreRequest", currentPmItem.prerequest);
    }
    if (currentPmItem.testScript) {
      _assertClassBrand(_AllureReporter_brand, this, _attachString).call(this, "TestScript", currentPmItem.testScript);
    }
    if (currentPmItem.consoleLogs.length) {
      _assertClassBrand(_AllureReporter_brand, this, _attachString).call(this, "ConsoleLogs", currentPmItem.consoleLogs);
    }
    if (requestData !== null && requestData !== void 0 && requestData.headers && (requestData === null || requestData === void 0 || (_requestData$headers = requestData.headers) === null || _requestData$headers === void 0 ? void 0 : _requestData$headers.count()) > 0) {
      this.allureRuntime.writeAttachment(this.currentTest, undefined, "Request Headers", _assertClassBrand(_AllureReporter_brand, this, _headerListToJsonBuffer).call(this, requestData.headers), {
        contentType: _allureJsCommons.ContentType.JSON
      });
    }
    if ((requestData === null || requestData === void 0 || (_requestData$body = requestData.body) === null || _requestData$body === void 0 ? void 0 : _requestData$body.mode) === "raw" && requestData.body.raw) {
      _assertClassBrand(_AllureReporter_brand, this, _attachString).call(this, "Request Body", requestData.body.raw);
    }
    if (response !== null && response !== void 0 && response.headers && (response === null || response === void 0 || (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers.count()) > 0) {
      this.allureRuntime.writeAttachment(this.currentTest, undefined, "Response Headers", _assertClassBrand(_AllureReporter_brand, this, _headerListToJsonBuffer).call(this, response.headers), {
        contentType: _allureJsCommons.ContentType.JSON
      });
    }
    if (response !== null && response !== void 0 && response.body) {
      this.allureRuntime.writeAttachment(this.currentTest, undefined, "Response Body", Buffer.from(response.body, "utf-8"), {
        contentType: _allureJsCommons.ContentType.TEXT
      });
    }
    this.allureRuntime.updateTest(this.currentTest, test => {
      if (requestDataURL) {
        test.parameters.push({
          name: "Request",
          value: requestDataURL
        });
      }
      if (response !== null && response !== void 0 && response.code) {
        test.parameters.push({
          name: "Response Code",
          value: response === null || response === void 0 ? void 0 : response.code.toString(),
          excluded: true
        });
      }
      if (testDescription) {
        var descriptionHtml = testDescription.replace(/[*]/g, "").replace(/\n/g, "<br>");
        test.description = testDescription;
        test.descriptionHtml = descriptionHtml;
      }
    });
    if (response && failedAssertions !== null && failedAssertions !== void 0 && failedAssertions.length) {
      var details = _assertClassBrand(_AllureReporter_brand, this, _escape).call(this, "Response code: ".concat(response.code, ", status: ").concat(response.status));
      this.allureRuntime.updateTest(this.currentTest, test => {
        test.status = _allureJsCommons.Status.FAILED;
        test.stage = _allureJsCommons.Stage.FINISHED;
        test.statusDetails = {
          message: _assertClassBrand(_AllureReporter_brand, this, _escape).call(this, failedAssertions.join(", ")),
          trace: details
        };
      });
    } else if (requestError) {
      var errorMsg = _assertClassBrand(_AllureReporter_brand, this, _escape).call(this, requestError);
      this.allureRuntime.updateTest(this.currentTest, test => {
        test.status = _allureJsCommons.Status.BROKEN;
        test.stage = _allureJsCommons.Stage.FINISHED;
        test.statusDetails = {
          message: errorMsg
        };
      });
    } else {
      this.allureRuntime.updateTest(this.currentTest, test => {
        test.status = _allureJsCommons.Status.PASSED;
        test.stage = _allureJsCommons.Stage.FINISHED;
      });
    }
    this.allureRuntime.stopTest(this.currentTest);
    this.allureRuntime.writeTest(this.currentTest);
  }
  onTest(err, args) {
    var _args$executions$2;
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem) {
      return;
    }
    var execScript = (_args$executions$2 = args.executions[0]) === null || _args$executions$2 === void 0 || (_args$executions$2 = _args$executions$2.script) === null || _args$executions$2 === void 0 || (_args$executions$2 = _args$executions$2.exec) === null || _args$executions$2 === void 0 ? void 0 : _args$executions$2.join("\n");
    if (!execScript) {
      return;
    }
    currentPmItem.testScript = execScript;

    // not typed postman-collection error property ?
    var testArgs = args.executions[0];
    if (!testArgs.error) {
      return;
    }
    var errName = testArgs.error.name;
    var errMsg = testArgs.error.message;
    var stepUuid = this.allureRuntime.startStep(this.currentTest, undefined, {
      name: errName,
      status: _allureJsCommons.Status.FAILED,
      stage: _allureJsCommons.Stage.FINISHED,
      statusDetails: {
        message: errMsg
      }
    });
    if (!stepUuid) {
      // no such test running, ignore reporting
      return;
    }
    currentPmItem.failedAssertions.push(errName);
    this.allureRuntime.stopStep(stepUuid);
  }
  onConsole(err, args) {
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem || err) {
      return;
    }
    if (args.level) {
      currentPmItem.consoleLogs.push("level: ".concat(args.level, ", messages: ").concat(args.messages.toString()));
    }
  }
  onRequest(err, args) {
    var _args$response;
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem) {
      return;
    }
    var req = args.request;
    var url = "".concat(req.url.protocol || "", "://").concat(args.request.url.getHost()).concat(req.url.getPathWithQuery());
    currentPmItem.requestData = {
      url: url,
      method: req.method,
      body: req.body,
      headers: req.headers
    };
    if (err) {
      currentPmItem.passed = false;
      currentPmItem.requestError = err.message;
    }
    if (!args.response) {
      return;
    }
    var respStream = args === null || args === void 0 || (_args$response = args.response) === null || _args$response === void 0 ? void 0 : _args$response.stream;
    var respBody = respStream ? Buffer.from(respStream).toString() : "";
    currentPmItem.responseData = {
      status: args.response.status,
      code: args.response.code,
      body: respBody,
      headers: args.response.headers
    };
  }
  onAssertion(err, args) {
    if (!this.currentTest) {
      return;
    }
    var currentPmItem = this.pmItemsByAllureUuid.get(this.currentTest);
    if (!currentPmItem) {
      return;
    }
    var stepUuid = this.allureRuntime.startStep(this.currentTest, undefined, {
      name: args.assertion
    });
    if (!stepUuid) {
      // no such test running, ignore reporting
      return;
    }
    this.allureRuntime.updateStep(stepUuid, step => {
      if (err && currentPmItem) {
        currentPmItem.passed = false;
        currentPmItem.failedAssertions.push(args.assertion);
        step.statusDetails = {
          message: err.message,
          trace: err.stack
        };
        step.status = _allureJsCommons.Status.FAILED;
      } else {
        step.status = _allureJsCommons.Status.PASSED;
      }
      step.stage = _allureJsCommons.Stage.FINISHED;
    });
    this.allureRuntime.stopStep(stepUuid);
  }
  onDone() {
    if (this.currentScope) {
      this.allureRuntime.writeScope(this.currentScope);
      this.currentScope = undefined;
    }
  }
}
function _pathToItem(item) {
  if (!item || !(typeof item.parent === "function") || !(typeof item.forEachParent === "function")) {
    return [];
  }
  var chain = [];
  item.forEachParent(parent => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    chain.unshift(parent.name || parent.id);
  });
  if (this.rootCollectionName) {
    chain.unshift(this.rootCollectionName);
  }
  return chain;
}
function _getFullName(item) {
  var chain = _assertClassBrand(_AllureReporter_brand, this, _pathToItem).call(this, item);
  return "".concat(chain.join("/"), "#").concat(item.name);
}
function _attachString(name, value) {
  var stringToAttach = Array.isArray(value) ? value.join("\n") : value;
  if (!stringToAttach) {
    return;
  }
  var content = Buffer.from(stringToAttach, "utf-8");
  this.allureRuntime.writeAttachment(this.currentTest, undefined, name, content, {
    contentType: _allureJsCommons.ContentType.TEXT
  });
}
function _headerListToJsonBuffer(headers) {
  var ret = {};
  headers.all().forEach(h => {
    ret[h.key] = h.value;
  });
  return Buffer.from(JSON.stringify(ret, null, 4), "utf-8");
}
function _escape(val) {
  return val.replace("\n", "").replace("\r", "")
  // eslint-disable-next-line @stylistic/quotes
  .replace('"', '"');
}
var _default = exports.default = AllureReporter;
module.exports = exports.default;
//# sourceMappingURL=index.js.map